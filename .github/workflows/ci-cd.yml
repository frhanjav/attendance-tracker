name: CI/CD Pipeline

on:
    push:
        branches: [main, develop]
    pull_request:
        branches: [main]

# Add permissions for security scanning
permissions:
    contents: read
    security-events: write
    actions: read

env:
    # GCP Configuration
    GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
    GCP_REGION: ${{ vars.GCP_REGION }}
    GCP_ARTIFACT_REGISTRY: ${{ vars.GCP_ARTIFACT_REGISTRY }}
    REGISTRY_URL: ${{ vars.GCP_REGION }}-docker.pkg.dev/${{ vars.GCP_PROJECT_ID }}/${{ vars.GCP_ARTIFACT_REGISTRY }}

    # Application Configuration
    PROJECT_NAME: attendance-tracker

    # Domain Configuration
    STAGING_DOMAIN: ${{ vars.STAGING_DOMAIN || 'staging.timetable.leverage.blog' }}
    PRODUCTION_DOMAIN: ${{ vars.PRODUCTION_DOMAIN || 'timetable.leverage.blog' }}

jobs:
    # Detect what changed in the PR/push
    detect-changes:
        runs-on: ubuntu-latest
        outputs:
            backend-changed: ${{ steps.changes.outputs.backend }}
            frontend-changed: ${{ steps.changes.outputs.frontend }}
            docker-compose-changed: ${{ steps.changes.outputs.docker-compose }}
            should-deploy: ${{ steps.deploy-check.outputs.should-deploy }}
            environment: ${{ steps.deploy-check.outputs.environment }}
            deploy-reason: ${{ steps.deploy-check.outputs.deploy-reason }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Detect file changes
              uses: dorny/paths-filter@v3
              id: changes
              with:
                  filters: |
                      backend:
                        - 'backend/**'
                      frontend:
                        - 'frontend/**'
                      docker-compose:
                        - 'docker-compose*.yml'
                        - 'nginx.reverse-proxy.*.conf'

            - name: Check if deployment should happen
              id: deploy-check
              run: |
                  # Check if any deployable changes occurred
                  BACKEND_CHANGED="${{ steps.changes.outputs.backend }}"
                  FRONTEND_CHANGED="${{ steps.changes.outputs.frontend }}"
                  DOCKER_COMPOSE_CHANGED="${{ steps.changes.outputs.docker-compose }}"

                  DEPLOY_REASON=""
                  SHOULD_DEPLOY="false"

                  # Build list of what changed
                  CHANGES_LIST=()
                  if [[ "$BACKEND_CHANGED" == "true" ]]; then
                    CHANGES_LIST+=("backend")
                  fi
                  if [[ "$FRONTEND_CHANGED" == "true" ]]; then
                    CHANGES_LIST+=("frontend")
                  fi
                  if [[ "$DOCKER_COMPOSE_CHANGED" == "true" ]]; then
                    CHANGES_LIST+=("docker-compose")
                  fi

                  # Only deploy if there are actual code/config changes
                  if [[ ${#CHANGES_LIST[@]} -gt 0 ]]; then
                    SHOULD_DEPLOY="true"
                    DEPLOY_REASON="Changes detected in: ${CHANGES_LIST[*]}"
                  else
                    SHOULD_DEPLOY="false"
                    DEPLOY_REASON="No deployable changes detected"
                  fi

                  # Determine deployment environment
                  if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
                    echo "environment=production" >> $GITHUB_OUTPUT
                  elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
                    echo "environment=staging" >> $GITHUB_OUTPUT
                  else
                    echo "environment=none" >> $GITHUB_OUTPUT
                    SHOULD_DEPLOY="false"
                    DEPLOY_REASON="Not on deployable branch"
                  fi

                  echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
                  echo "deploy-reason=$DEPLOY_REASON" >> $GITHUB_OUTPUT

                  echo "üîç Deployment decision: $SHOULD_DEPLOY"
                  echo "üìù Reason: $DEPLOY_REASON"

    # Build Check (No tests yet - placeholder for future)
    build-check:
        needs: detect-changes
        if: needs.detect-changes.outputs.backend-changed == 'true' || needs.detect-changes.outputs.frontend-changed == 'true'
        runs-on: ubuntu-latest

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Setup Node.js for Backend
              if: needs.detect-changes.outputs.backend-changed == 'true'
              uses: actions/setup-node@v4
              with:
                  node-version: '20'
                  cache: 'npm'
                  cache-dependency-path: backend/package-lock.json

            - name: Install backend dependencies
              if: needs.detect-changes.outputs.backend-changed == 'true'
              working-directory: ./backend
              run: npm ci

            - name: Build backend
              if: needs.detect-changes.outputs.backend-changed == 'true'
              working-directory: ./backend
              run: npm run build

            - name: Setup Node.js for Frontend
              if: needs.detect-changes.outputs.frontend-changed == 'true'
              uses: actions/setup-node@v4
              with:
                  node-version: '20'
                  cache: 'npm'
                  cache-dependency-path: frontend/package-lock.json

            - name: Install frontend dependencies
              if: needs.detect-changes.outputs.frontend-changed == 'true'
              working-directory: ./frontend
              run: npm ci

            - name: Build frontend
              if: needs.detect-changes.outputs.frontend-changed == 'true'
              working-directory: ./frontend
              run: npm run build

    # Security Scan
    security-scan:
        needs: detect-changes
        if: needs.detect-changes.outputs.backend-changed == 'true' || needs.detect-changes.outputs.frontend-changed == 'true'
        runs-on: ubuntu-latest
        permissions:
            contents: read
            security-events: write
            actions: read

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Run Trivy vulnerability scanner
              uses: aquasecurity/trivy-action@master
              with:
                  scan-type: 'fs'
                  scan-ref: '.'
                  format: 'sarif'
                  output: 'trivy-results.sarif'

            - name: Upload Trivy scan results to GitHub Security tab
              uses: github/codeql-action/upload-sarif@v3
              if: always() && github.event_name != 'pull_request'
              with:
                  sarif_file: 'trivy-results.sarif'
              continue-on-error: true

            - name: Show scan summary
              if: always()
              run: |
                  echo "üîç Security scan completed"
                  if [ -f "trivy-results.sarif" ]; then
                    echo "‚úÖ SARIF report generated successfully"
                    # Show a summary of findings if any
                    if command -v jq &> /dev/null; then
                      ISSUES=$(jq '.runs[0].results | length' trivy-results.sarif 2>/dev/null || echo "0")
                      echo "üìä Found $ISSUES security issues"
                    fi
                  else
                    echo "‚ùå SARIF report not found"
                  fi

    # Build and Push Docker Images
    build-and-push:
        needs: [detect-changes, build-check]
        if: always() && needs.build-check.result == 'success' && (needs.detect-changes.outputs.backend-changed == 'true' || needs.detect-changes.outputs.frontend-changed == 'true') && needs.detect-changes.outputs.should-deploy == 'true'
        runs-on: ubuntu-latest
        outputs:
            backend-image: ${{ steps.build-backend.outputs.image }}
            frontend-image: ${{ steps.build-frontend.outputs.image }}

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Authenticate to Google Cloud
              uses: google-github-actions/auth@v2
              with:
                  credentials_json: ${{ secrets.GCP_SA_KEY }}

            - name: Configure Docker for GCP
              run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

            - name: Build and push backend image
              id: build-backend
              if: needs.detect-changes.outputs.backend-changed == 'true'
              run: |
                  IMAGE_TAG=${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}-backend:${{ github.sha }}
                  LATEST_TAG=${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}-backend:latest

                  docker build -t $IMAGE_TAG -t $LATEST_TAG ./backend
                  docker push $IMAGE_TAG
                  docker push $LATEST_TAG

                  echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT

            - name: Build and push frontend image
              id: build-frontend
              if: needs.detect-changes.outputs.frontend-changed == 'true'
              run: |
                  IMAGE_TAG=${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}-frontend:${{ github.sha }}
                  LATEST_TAG=${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}-frontend:latest

                  docker build -t $IMAGE_TAG -t $LATEST_TAG ./frontend
                  docker push $IMAGE_TAG
                  docker push $LATEST_TAG

                  echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT

    # Deploy with Docker Compose (skipping Terraform - manage infrastructure manually)
    deploy-application:
        needs: [detect-changes, build-and-push]
        if: always() && needs.detect-changes.outputs.should-deploy == 'true' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop') && (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')
        runs-on: ubuntu-latest

        env:
            ENVIRONMENT: ${{ needs.detect-changes.outputs.environment }}

        steps:
            - name: Display deployment info
              run: |
                  echo "üöÄ Deploying to ${{ env.ENVIRONMENT }}"
                  echo "üìù Deploy reason: ${{ needs.detect-changes.outputs.deploy-reason }}"
                  echo "üîç Build job result: ${{ needs.build-and-push.result }}"
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Authenticate to Google Cloud
              uses: google-github-actions/auth@v2
              with:
                  credentials_json: ${{ secrets.GCP_SA_KEY }}

            - name: Setup gcloud CLI
              uses: google-github-actions/setup-gcloud@v2

            - name: Configure Docker for GCP
              run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

            - name: Prepare nginx configuration
              run: |
                  # Use environment-specific nginx configuration
                  if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                    NGINX_TEMPLATE="nginx.reverse-proxy.production.conf"
                    DOMAIN="${{ env.PRODUCTION_DOMAIN }}"
                  else
                    NGINX_TEMPLATE="nginx.reverse-proxy.staging.conf"
                    DOMAIN="${{ env.STAGING_DOMAIN }}"
                  fi

                  SERVER_PORT="80"
                  BACKEND_PORT="3000"

                  echo "üîß Using template: $NGINX_TEMPLATE"
                  echo "üåê Domain: $DOMAIN"
                  echo "üîå Port: $SERVER_PORT"

                  # Copy the environment-specific nginx config
                  cp $NGINX_TEMPLATE nginx.reverse-proxy.conf
                      
                  echo "‚úÖ Using nginx config for ${{ env.ENVIRONMENT }}"
                  echo "üìÑ Nginx config preview:"
                  head -20 nginx.reverse-proxy.conf

            - name: Update Docker Compose with new image tags
              run: |
                  # Use environment-specific compose file
                  COMPOSE_FILE="docker-compose.${{ env.ENVIRONMENT }}.yml"

                  # Update compose file with new image tags from build job outputs
                  if [[ -n "${{ needs.build-and-push.outputs.backend-image }}" ]]; then
                    echo "üîÑ Updating backend image to: ${{ needs.build-and-push.outputs.backend-image }}"
                    sed -i "s|image: .*attendance-tracker-backend.*|image: ${{ needs.build-and-push.outputs.backend-image }}|g" $COMPOSE_FILE
                  else
                    echo "‚ÑπÔ∏è Backend image not updated - using existing image"
                  fi

                  if [[ -n "${{ needs.build-and-push.outputs.frontend-image }}" ]]; then
                    echo "üîÑ Updating frontend image to: ${{ needs.build-and-push.outputs.frontend-image }}"
                    sed -i "s|image: .*attendance-tracker-frontend.*|image: ${{ needs.build-and-push.outputs.frontend-image }}|g" $COMPOSE_FILE
                  else
                    echo "‚ÑπÔ∏è Frontend image not updated - using existing image"
                  fi

                  echo "üìÑ Docker Compose file updated:"
                  head -20 $COMPOSE_FILE

            - name: Setup SSH
              run: |
                  # Create SSH directory and add private key
                  mkdir -p ~/.ssh

                  # Debug: Show environment
                  echo "üîç Environment: ${{ env.ENVIRONMENT }}"

                  # Use environment-specific SSH key, server host, and server user
                  if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                    SERVER_HOST="${{ secrets.PRODUCTION_SERVER_HOST }}"
                    SSH_PRIVATE_KEY="${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}"
                    SERVER_USER="${{ secrets.PRODUCTION_SERVER_USER }}"
                    DOMAIN="${{ env.PRODUCTION_DOMAIN }}"
                    echo "üîç Using production server configuration"
                  else
                    SERVER_HOST="${{ secrets.STAGING_SERVER_HOST }}"
                    SSH_PRIVATE_KEY="${{ secrets.STAGING_SSH_PRIVATE_KEY }}"
                    SERVER_USER="${{ secrets.STAGING_SERVER_USER }}"
                    DOMAIN="${{ env.STAGING_DOMAIN }}"
                    echo "üîç Using staging server configuration"
                  fi

                  # Debug: Show what SERVER_HOST we're using (mask for security)
                  echo "üîç SERVER_HOST: ${SERVER_HOST:0:3}***${SERVER_HOST: -3}"
                  echo "üîç SERVER_USER: ${SERVER_USER:0:2}***${SERVER_USER: -2}"
                  echo "üîç DOMAIN: $DOMAIN"

                  # Check if SERVER_HOST is set
                  if [[ -z "$SERVER_HOST" ]]; then
                    echo "‚ùå SERVER_HOST is empty! Check your secrets configuration."
                    echo "Required secrets for ${{ env.ENVIRONMENT }}:"
                    if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                      echo "  - PRODUCTION_SERVER_HOST"
                      echo "  - PRODUCTION_SSH_PRIVATE_KEY"
                      echo "  - PRODUCTION_SERVER_USER"
                    else
                      echo "  - STAGING_SERVER_HOST"
                      echo "  - STAGING_SSH_PRIVATE_KEY"
                      echo "  - STAGING_SERVER_USER"
                    fi
                    exit 1
                  fi

                  # Check if SERVER_USER is set
                  if [[ -z "$SERVER_USER" ]]; then
                    echo "‚ùå SERVER_USER is empty! Check your secrets configuration."
                    echo "Required secrets for ${{ env.ENVIRONMENT }}:"
                    if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                      echo "  - PRODUCTION_SERVER_USER"
                    else
                      echo "  - STAGING_SERVER_USER"
                    fi
                    exit 1
                  fi

                  # Check if SSH_PRIVATE_KEY is set
                  if [[ -z "$SSH_PRIVATE_KEY" ]]; then
                    echo "‚ùå SSH_PRIVATE_KEY is empty! Check your secrets configuration."
                    echo "Required secrets for ${{ env.ENVIRONMENT }}:"
                    if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                      echo "  - PRODUCTION_SSH_PRIVATE_KEY"
                    else
                      echo "  - STAGING_SSH_PRIVATE_KEY"
                    fi
                    exit 1
                  fi

                  # Set up SSH key
                  echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa

                  # Debug: Check SSH key format
                  echo "üîç SSH key first line:"
                  head -n 1 ~/.ssh/id_rsa
                  echo "üîç SSH key last line:"
                  tail -n 1 ~/.ssh/id_rsa
                  echo "üîç SSH key file permissions:"
                  ls -la ~/.ssh/id_rsa

                  # Add server to known_hosts to avoid SSH verification prompt
                  ssh-keyscan -H "$SERVER_HOST" >> ~/.ssh/known_hosts
                  echo "‚úÖ Added $SERVER_HOST to known_hosts"

                  # Debug: Test SSH connection
                  echo "üîç Testing SSH connection..."
                  ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "echo 'SSH connection successful'" || echo "‚ùå SSH connection failed"

                  # Export variables for next step
                  echo "SERVER_HOST=$SERVER_HOST" >> $GITHUB_ENV
                  echo "SERVER_USER=$SERVER_USER" >> $GITHUB_ENV
                  echo "DOMAIN=$DOMAIN" >> $GITHUB_ENV

            - name: Deploy to Server
              run: |
                  echo "üöÄ Deploying to ${{ env.ENVIRONMENT }} server..."

                  # Use environment variables set in previous step
                  echo "üîç SERVER_HOST: ${SERVER_HOST}"
                  echo "üîç SERVER_USER: ${SERVER_USER}"

                  # Define compose file and database URL based on environment
                  if [[ "${{ env.ENVIRONMENT }}" == "production" ]]; then
                    COMPOSE_FILE="docker-compose.production.yml"
                    DATABASE_URL="${{ secrets.PRODUCTION_DATABASE_URL }}"
                    OAUTH_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
                    OAUTH_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
                  else
                    COMPOSE_FILE="docker-compose.staging.yml"
                    DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}"
                    OAUTH_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
                    OAUTH_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
                  fi

                  PROJECT_DIR="/home/${SERVER_USER}/attendance-tracker"

                  echo "üì° Connecting to ${SERVER_USER}@${SERVER_HOST}..."

                  # First, ensure the project directory exists and set up the environment
                  echo "üîç Setting up project directory..."
                  ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "
                  # Create project directory if it doesn't exist
                  mkdir -p ${PROJECT_DIR}

                  # Add user to docker group if not already (needed for Docker access)
                  if ! groups \$USER | grep -q docker; then
                    echo 'üîß Adding user to docker group...'
                    sudo usermod -aG docker \$USER
                    echo '‚ö†Ô∏è  User added to docker group. Note: Group changes take effect on next login.'
                  fi

                  echo '‚úÖ Project directory set up'
                  "

                  # Copy updated docker-compose file to server
                  echo "üîç Copying deployment files..."
                  scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $COMPOSE_FILE nginx.reverse-proxy.conf ${SERVER_USER}@${SERVER_HOST}:${PROJECT_DIR}/

                  # Execute deployment commands on the server
                  echo "üîç Executing deployment..."
                  ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "
                  set -e

                  echo 'üìÅ Navigating to project directory...'
                  cd ${PROJECT_DIR}

                  echo 'üîç Checking current working directory and files...'
                  pwd
                  ls -la

                  echo '‚öôÔ∏è Creating environment file with database URL from GitHub secrets...'
                  echo \"DATABASE_URL=$DATABASE_URL\" > .env
                  echo \"JWT_SECRET=${{ secrets.JWT_SECRET || 'staging-jwt-secret-changeme' }}\" >> .env
                  echo \"NODE_ENV=${{ env.ENVIRONMENT }}\" >> .env
                  echo \"GOOGLE_CLIENT_ID=$OAUTH_CLIENT_ID\" >> .env
                  echo \"GOOGLE_CLIENT_SECRET=$OAUTH_CLIENT_SECRET\" >> .env
                  echo \"FRONTEND_URL=https://$DOMAIN\" >> .env
                  echo \"GOOGLE_CALLBACK_URL=https://$DOMAIN/api/v1/auth/google/callback\" >> .env
                  echo '‚úÖ Environment file created'
                  echo 'üìÑ Environment file contents:'
                  cat .env

                  echo 'üê≥ Checking Docker and Docker Compose...'
                  docker --version
                  docker-compose --version

                  echo 'üîç Checking current Docker containers...'
                  docker ps -a || echo 'No containers found'

                  echo 'üì¶ Pulling latest Docker images...'
                  set -e  # Exit on any error
                  echo 'üîç Pulling images...'
                  docker-compose -f $COMPOSE_FILE pull || (echo '‚ùå Failed to pull images' && exit 1)

                  echo 'üîÑ Stopping old containers...'
                  docker-compose -f $COMPOSE_FILE down || (echo '‚ùå Failed to stop containers' && exit 1)

                  echo 'üöÄ Starting new containers...'
                  docker-compose -f $COMPOSE_FILE up -d || (echo '‚ùå Failed to start containers' && exit 1)

                  echo '‚è≥ Waiting for containers to be ready...'
                  sleep 30

                  echo 'üîç Verifying container health...'
                  # Check if all containers are running
                  RUNNING_CONTAINERS=$(docker-compose -f $COMPOSE_FILE ps --services --filter status=running | wc -l)
                  TOTAL_CONTAINERS=$(docker-compose -f $COMPOSE_FILE ps --services | wc -l)

                  echo "Running containers: $RUNNING_CONTAINERS/$TOTAL_CONTAINERS"

                  if [ $RUNNING_CONTAINERS -ne $TOTAL_CONTAINERS ]; then
                    echo '‚ùå Not all containers are running!'
                    docker-compose -f $COMPOSE_FILE ps
                    docker-compose -f $COMPOSE_FILE logs --tail=20
                    exit 1
                  fi

                  echo 'üîç Testing backend health endpoint...'
                  BACKEND_CONTAINER="attendance_backend_${{ env.ENVIRONMENT }}"
                  for i in {1..10}; do
                    if docker exec $BACKEND_CONTAINER wget -q --spider http://localhost:3000/api/v1/health 2>/dev/null; then
                      echo '‚úÖ Backend health check passed!'
                      break
                    else
                      echo "‚è≥ Health check attempt $i/10..."
                      if [ $i -eq 10 ]; then
                        echo '‚ùå Backend health check failed after 10 attempts!'
                        docker logs $BACKEND_CONTAINER --tail=20
                        exit 1
                      fi
                      sleep 5
                    fi
                  done

                  echo 'üßπ Cleaning up old Docker images...'
                  docker image prune -f

                  echo '‚úÖ Deployment completed successfully!'
                  echo 'üìä Service status:'
                  docker-compose -f $COMPOSE_FILE ps
                  echo 'üîç Container logs (last 5 lines):'
                  docker-compose -f $COMPOSE_FILE logs --tail=5
                  echo '‚úÖ Deployment to ${{ env.ENVIRONMENT }} server completed!'
                  "
    # Notification
    notify:
        needs: [deploy-application]
        if: always()
        runs-on: ubuntu-latest

        steps:
            - name: Notify deployment status
              run: |
                  if [[ "${{ needs.deploy-application.result }}" == "success" ]]; then
                    echo "‚úÖ Docker images built and pushed successfully!"
                    echo "üì¶ Images are ready for deployment with Docker Compose"
                  else
                    echo "‚ùå Build or deployment preparation failed!"
                  fi
