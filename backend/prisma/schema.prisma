// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- Enums ---
enum AttendanceStatus {
  OCCURRED // Class happened, student attended
  MISSED   // Class happened, student did NOT attend (or default if no record)
  CANCELLED // Class did not happen (globally cancelled by admin)
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  emailVerified Boolean @default(false)

  streamsOwned    Stream[]           @relation("StreamOwner")
  streamMemberships StreamMembership[]
  attendanceRecords AttendanceRecord[]
  bulkEntries     BulkAttendanceEntry[]
}

model Stream {
  id          String   @id @default(cuid())
  name        String
  streamCode  String   @unique @default(cuid()) // Simple unique code for joining
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User               @relation("StreamOwner", fields: [ownerId], references: [id])
  members     StreamMembership[]
  timetables  Timetable[]
  // Link global statuses here if needed, or handle via AttendanceRecord
  // cancelledClasses CancelledClass[] // Example if storing cancellations separately
  attendanceRecords AttendanceRecord[]
  bulkEntries     BulkAttendanceEntry[]

  @@index([ownerId])
}

// Join table for users and streams
model StreamMembership {
  id        String   @id @default(cuid())
  userId    String
  streamId  String
  role      String   @default("member") // e.g., "admin", "member"
  joinedAt  DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stream    Stream   @relation(fields: [streamId], references: [id], onDelete: Cascade)

  @@unique([userId, streamId])
  @@index([userId])
  @@index([streamId])
}

model Timetable {
  id          String   @id @default(cuid())
  streamId    String
  name        String   // e.g., "Semester 1 Timetable"
  validFrom   DateTime // Start date this timetable is active
  validUntil  DateTime? // Optional end date
  createdAt   DateTime @default(now())

  stream      Stream           @relation(fields: [streamId], references: [id], onDelete: Cascade)
  entries     TimetableEntry[]

  @@index([streamId])
  @@index([validFrom])
}

model TimetableEntry {
  id          String   @id @default(cuid())
  timetableId String
  dayOfWeek   Int      // ISO 8601 day of week (1 = Monday, 7 = Sunday)
  subjectName String
  courseCode  String?
  startTime   String?  // Optional: e.g., "09:00"
  endTime     String?  // Optional: e.g., "10:00"

  timetable   Timetable @relation(fields: [timetableId], references: [id], onDelete: Cascade)

  @@index([timetableId])
  @@index([dayOfWeek])
}

// Represents a specific class instance on a specific date, derived from TimetableEntry
// Could be implicitly calculated or explicitly stored if needed for complex overrides/notes
// For simplicity here, we link AttendanceRecord directly to Stream/Subject/Date

model AttendanceRecord {
  id          String   @id @default(cuid())
  userId      String
  streamId    String
  subjectName String
  // Store courseCode at time of record creation for historical accuracy
  courseCode  String?
  classDate   DateTime // The specific date the class was scheduled/held
  status      AttendanceStatus @default(MISSED)
  markedAt    DateTime @updatedAt // When the status was last changed

  // Optional: Track who marked it if needed (e.g., distinguishing admin actions)
  // markedByUserId String?

  // Optional: Add notes if needed later
  // notes String?

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stream      Stream   @relation(fields: [streamId], references: [id], onDelete: Cascade)
  // markedBy User? // If tracking who marked is needed

  // Unique constraint: One status per user per class instance
  @@unique([userId, streamId, subjectName, classDate]) // Ensure one record per user/stream/subject/date
  @@index([userId])
  @@index([streamId])
  @@index([classDate])
  @@index([status]) // Index status for faster querying
}

// For bulk entry feature
model BulkAttendanceEntry {
  id              String   @id @default(cuid())
  userId          String
  streamId        String
  subjectName     String
  courseCode      String?
  attendedClasses Int      // Number of classes attended by the user for this subject
  // Store total held classes *at the time of calculation* based on new definition
  totalHeldClasses Int?
  calculationDate DateTime @default(now()) // When this bulk entry was made/calculated
  startDate       DateTime // Start date used for calculation
  endDate         DateTime // End date used for calculation (usually current date)

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stream          Stream   @relation(fields: [streamId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([streamId])
  @@index([subjectName])
}